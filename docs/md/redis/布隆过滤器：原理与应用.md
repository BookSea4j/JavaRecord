在日常生活和工作中，我们经常需要处理海量的数据，筛选出有用的信息。

这个时候，布隆过滤器（Bloom Filter）就派上了用场。 作为一种空间高效的概率型数据结构，布隆过滤器能够快速有效地检测一个元素是否属于一个集合。其应用广泛，从网络爬虫的网页去重，到数据库查询优化，乃至比特币网络的交易匹配，都离不开它的身影。

本文将深入解析布隆过滤器的原理以及如何在实际情况中进行使用，希望能帮助你更好地理解和运用这种强大的工具。

## 布隆过滤器简介

在开发过程中，经常要判断一个元素是否在一个集合中。**假设你现在要给项目添加IP黑名单功能，此时你手上有大约 1亿个恶意IP的数据集，有一个IP发起请求，你如何判断这个IP在不在你的黑名单中？**

类似这种问题用Java自己的Collection和Map很难处理，因为它们存储元素本身，会造成内存不足，而我们只关心元素存不存在，对于元素的值我们并不关心，具体值是什么并不重要。

「**布隆过滤器**」可以用来解决类似的问题，具有运行快速，内存占用小的特点，它是一个保存了很长的二级制向量，同时结合 Hash 函数实现的。

而高效插入和查询的代价就是，它是一个基于概率的数据结构，**只能告诉我们一个元素绝对不在集合内，对于存在集合内的元素有一定的误判率**。

## fpp

布隆过滤器中总是会存在误判率，因为哈希碰撞是不可能百分百避免的。布隆过滤器对这种误判率称之为「**假阳性概率**」，即：**False Positive Probability**，简称为 fpp。

在实践中使用布隆过滤器时可以自己定义一个 fpp，然后就可以根据布隆过滤器的理论计算出需要多少个哈希函数和多大的位数组空间。需要注意的是这个 fpp 不能定义为 100%，因为无法百分保证不发生哈希碰撞。

## 布隆过滤器原理

下图表示向布隆过滤器中添加元素 **www.123.com** 和 **www.456.com** 的过程，它使用了 func1 和 func2 两个简单的哈希函数。
![](https://mmbiz.qpic.cn/mmbiz_png/jC8rtGdWScOVMmTVs8zjnCmKg1cMq38QibmBrFolPsnVmBricTHCUicm7ShVxJibS4GsIEpDOiaykjaw1oMkm4CUunA/640)

其基本原理如下：

1. **初始化**：当我们创建一个布隆过滤器时，我们首先创建一个全由0组成的位数组（bit array)。同时，我们还需选择几个独立的哈希函数，每个函数都可以将集合中的元素映射到这个位数组的某个位置。
2. **添加元素**：在布隆过滤器中添加一个元素时，我们会将此元素通过所有的哈希函数进行映射，得到在位数组中的几个位置，然后将这些位置标记为1。
3. **查询元素**：如果我们要检查一个元素是否在集合中，我们同样使用这些哈希函数将元素映射到位数组中的几个位置，**如果所有的位置都被标记为1，那么我们就可以说该元素可能在集合中。如果有任何一个位置不为1，那么该元素肯定不在集合中**。

通过其原理可以知道，我们可以提高数组长度以及 hash 计算次数来降低误报率，但是相应的 CPU、内存的消耗也会相应地提高，会增加存储和计算的开销。因此，布隆过滤器的使用需要在误判率和性能之间进行权衡。

## 布隆过滤器的特点

布隆过滤器有以下两个特点：

 - **只要返回数据不存在，则肯定不存在。** 
 - **返回数据存在，不一定存在**。 

布隆过滤器的误判率主要来源于「**哈希碰撞**」。因为位数组的大小有限，不同的元素可能会被哈希到相同的位置，导致即使某个元素并未真正被加入过滤器，也可能因为其他已经存在的元素而让所有哈希函数映射的位都变为了1，从而误判为存在。这就是布隆过滤器的“假阳性”错误。

 在有限的数组长度中存放大量的数据，即便是再完美的 Hash 算法也会有冲突，所以有可能两个完全不同的 A、B 两个数据最后定位到的位置是一模一样的。这时拿 B 进行查询时那自然就是误报了。

## 布隆过滤器使用

###  布隆过滤器中的数据可不可以删除 

**布隆过滤器判断一个元素存在就是判断对应位置是否为 1 来确定的，但是如果要删除掉一个元素是不能直接把 1 改成 0 的**，因为这个位置可能存在其他元素。

所以如果要支持删除，最简单的做法就是加一个计数器，就是说位数组的每个位如果不存在就是 0，存在几个元素就存具体的数字，而不仅仅只是存 1，但是这样会带来其他问题，本来存 1 就是一位就可以满足了，但是如果要存具体的数字比如说 2，那就需要 2 位了，所以带有计数器的布隆过滤器会占用更大的空间。

以下是带有计数器的布隆过滤器的实现：

```xml
<dependency>
    <groupId>com.baqend</groupId>
    <artifactId>bloom-filter</artifactId>
    <version>1.0.7</version>
</dependency>
```

新建一个带有计数器的布隆过滤器 CountingBloomFilter：

```java
import orestes.bloomfilter.FilterBuilder;

public class CountingBloomFilter {
    public static void main(String[] args) {
        orestes.bloomfilter.CountingBloomFilter<String> cbf = new FilterBuilder(10000,
                0.01).countingBits(8).buildCountingBloomFilter();

        cbf.add("zhangsan");
        cbf.add("lisi");
        cbf.add("wangwu");
        System.out.println("是否存在王五：" + cbf.contains("wangwu")); //true
        cbf.remove("wangwu");
        System.out.println("是否存在王五：" + cbf.contains("wangwu")); //false
    }
}
```

构建布隆过滤器前面 两个参数一个就是期望的元素数，一第二个就是 fpp 值，后面的 countingBits 参数就是计数器占用的大小，这里传了一个 8 位，即最多允许 255 次重复，如果不传的话这里默认是 16 位大小，即允许 65535次重复。

### 布隆过滤器应该设计为多大

假设在布隆过滤器里面有 k 个哈希函数，m 个比特位（也就是位数组长度），以及 n 个已插入元素，错误率会近似于 (1-ekn/m)k，所以你只需要先确定可能插入的数据集的容量大小 n，然后再调整 k 和 m 来为你的应用配置过滤器。

### 布隆过滤器应该使用多少个哈希函数

对于给定的 m（比特位个数）和 n（集合元素个数），最优的 k（哈希函数个数）值为: (m/n)ln(2)。

### 布隆过滤器的时间复杂度和空间复杂度

对于一个 m（比特位个数）和 k（哈希函数个数）值确定的布隆过滤器，添加和判断操作的时间复杂度都是 O(k)，这意味着每次你想要插入一个元素或者查询一个元素是否在集合中，只需要使用 k 个哈希函数对该元素求值，然后将对应的比特位标记或者检查对应的比特位即可。

## 布隆过滤器实现

###  Guava的布隆过滤器的实现

Guava有自带的布隆过滤器的实现：

```java
public class BloomFilterTest {

    public static void main(String[] args) {
        long star = System.currentTimeMillis();
        BloomFilter<Integer> filter = BloomFilter.create(
                Funnels.integerFunnel(),
                //预计存放多少数据
                10000000,
                //可以接受的误报率
                0.01);

        for (int i = 0; i < 10000000; i++) {
            filter.put(i);
        }

        Assert.isTrue(filter.mightContain(1),"不存在");
        Assert.isTrue(filter.mightContain(2),"不存在");
        Assert.isTrue(filter.mightContain(3),"不存在");
        Assert.isTrue(filter.mightContain(10000000),"不存在");
        long end = System.currentTimeMillis();
        System.out.println("执行时间：" + (end - star));

    }
}
```

Guava自带的布隆过滤器，只需直接传入预期的数据量以及fpp，它会自动帮我们计算数组长度和哈希次数。

这段代码创建了一个预期存储10000000个整数的布隆过滤器，误报率为1%。

然后，代码将0到9999999的所有整数添加到过滤器中。然后，对数字1、2、3和10000000进行测试。对于前三个数字，因为他们已经被添加到过滤器中，所以mightContain返回true；对于最后一个数字（10000000），由于它并未加入过滤器，mightContain方法可能返回false，但也有1%的概率返回true（误报）。

### BitMap（位图）

**BitMap不会存在误判的情况，位图也是布隆过滤器的实现，但是占用内存空间随集合内最大元素的增大而增大。而布隆过滤器，因为其可能一个bit为多个元素作标识，这就保证了它的空间利用率。这两种方式根据业务进行选择。**

以32位整型为例，它可以表示数字的个数为2^32，可以申请一个位图，让每个整数对应的位图中的一个bit，这样2^32个数需要的位图的大小为512MB。

具体实现的思路为：申请一个512MB的位图，并把所有的位都初始化为0，接着遍历所有的整数，对遍历到的数字，把相应的位置上的bit设置为1。

最后判断待查找的数对应的位图上的值是多少，如果是0，那么表示这个数字不存在，如果是1，那么表示这个数字存在。

Java中有BitMap的实现类：`BitSet`，Java中的`BitSet`类创建一种特殊类型的数组来保存位值。该类实现了一个可动态扩展的位向量。位集的大小会随着需要而增长。这使得它成为了实现位图的理想选择。

```java
public class BitMapTest {
        public static void main(String[] args) {
                int[] array = {3, 8, 5, 7, 1};
                BitSet bitSet = new BitSet(5);
 
                for (int i = 0; i < array.length; i++) {
                        bitSet.set(array[i], true);
                }
 
                bitSet.stream().forEach(e -> System.out.println(e));
 
        }
}
```

这段代码首先创建了一个`BitSet`实例，然后遍历数组，把数组中每个元素值设为位集中对应索引的位。例如，数组中的第一个元素是3，那么就把位集的第三位设为`true`。最后，使用`stream()`方法和lambda表达式打印出所有被设置为`true`的位的索引。

这就是本篇文章的全部内容。在总结我们对布隆过滤器的探讨时，我们可以看到其独特和强大之处。这种数据结构经常被应用于各种场景，包括缓存系统、网络路由器，甚至是大规模分布式数据库中。尽管它存在一定的误报率，但是通过精心选择哈希函数的数量和位数组的大小，我们可以降低这个概率。

布隆过滤器的高效性、节省空间的特性以及灵活的设计使得它成为解决各种问题的有力工具。但需要注意的是，作为工程师和开发者，我们必须理解并接受其限制和妥协，如假阳性的可能性和无法从过滤器中删除元素的事实。然而，正是这些限制，为我们提供了改进和创新的机会，推动我们寻找更多高效、灵活的数据处理方法。

总的来说，布隆过滤器是一个强大而高效的工具，值得我们深入理解和广泛应用。同时，它也是计算机科学中众多神奇的示例之一，展示了如何通过聪明的设计和妥协，解决现实世界中的挑战问题。
